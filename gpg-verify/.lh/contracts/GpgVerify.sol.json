{
    "sourceFile": "contracts/GpgVerify.sol",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1711009591568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1711009626706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n // SPDX-License-Identifier: GPL-3.0-only\n-pragma solidity ^0.7.0;\n+pragma solidity ^0.8.0;\n pragma experimental ABIEncoderV2;\n \n import \"@cartesi/compute-sdk/contracts/CartesiComputeInterface.sol\";\n \n"
                },
                {
                    "date": 1711009646595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n // SPDX-License-Identifier: GPL-3.0-only\n-pragma solidity ^0.8.0;\n+pragma solidity ^0.8.;\n pragma experimental ABIEncoderV2;\n \n import \"@cartesi/compute-sdk/contracts/CartesiComputeInterface.sol\";\n \n"
                }
            ],
            "date": 1711009591568,
            "name": "Commit-0",
            "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@cartesi/compute-sdk/contracts/CartesiComputeInterface.sol\";\n\ncontract GpgVerify {\n\n    CartesiComputeInterface cartesiCompute;\n\n    bytes32 templateHash = 0xb5907eafa8a2c0f43249afcef27d207785e427ca4a1d7db8a4a05c7f1b7e1df5;\n\n    // this dApp has an ext2 file-system (at 0x9000..) and two input drives (at 0xa000.. and 0xb000..), so the output will be at 0xc000..\n    uint64 outputPosition = 0xc000000000000000;\n    // output will be \"0\" (success, no errors), \"1\" (failure), or some other error code that certainly fits into the minimum size of 32 bytes\n    uint8 outputLog2Size = 5;\n\n    uint256 finalTime = 1e11;\n    uint256 roundDuration = 75;\n\n    // document that was signed\n    bytes document = \"My public statement\\n\";\n\n    // detached signature for the document, produced with a private key\n    // - the dApp off-chain code must contain the corresponding public key in order to verify the signature\n    bytes signature = hex'8901d20400010a003d162104dbbbb50ddc0910795f7c0b48a86d9cb964eb527e05025f19fa431f1c6465736361727465732e7475746f7269616c7340636172746573692e696f'\n                      hex'000a0910a86d9cb964eb527ed88f0bf745cac22eca54a050edf5ce62ab5c8857bab9807d4b6cc4b01b47c640669f14c9457d129225d005585f7a4cec2c41bd088b0d622c4ee2'\n                      hex'9eecb4a451461e421d0067575bd845818a12df0b197e525da3dea2c89f0210325d766a11da824d9469bea5add6c9f91c09098f72cca806f4b0eb3ff622531171f9ae5b855366'\n                      hex'd250d08e05327549a9a958b44530f2a05cd9b6aa463eda223f16ff8655ab2e4bf7f66bb2fa29913c1f04080a24dd10e754d277c346909a3510305b7fd9ca2a4bbd412fc50818'\n                      hex'331b40461380174434f90046bfb6278419b69259e56abfa504c5965e37d1aa355302d8b6aac98abe5be1c02c78d5a2e9e4df0eba43a91717407811e20b800120f349aa1b51a1'\n                      hex'e4ad5ffdf6248ef0201b275e947d81ed8267a473778cab78ead5f39e60edaf9c17a6c558eeb0ca7e7acc1343a1f7a431d21598edd470a080ed377ab0c4824f95589ab1c40568'\n                      hex'e8a28b36ac20116586f89ebe193af5898aa947ada15bbbb8d09e3894c33d7bdb20a8b1bc6be60ac03fdbc0be0ffdfa326c';\n\n    // corresponding document and signature data to be sent as input drives to the off-chain Cartesi Machine\n    // - this machine expects the first four bytes of the input data to encode the length of the content of interest\n    bytes documentData = new bytes(1024);\n    bytes signatureData = new bytes(1024);\n\n    constructor(address cartesiComputeAddress) {\n        cartesiCompute = CartesiComputeInterface(cartesiComputeAddress);\n\n        // prepares data: computation expects input data to be prepended by four bytes that encode the length of the content\n        prependDataWithContentLength(document, documentData);\n        prependDataWithContentLength(signature, signatureData);\n    }\n\n    function prependDataWithContentLength(bytes storage input, bytes storage output) internal {\n        // length is assumed to fit in four bytes\n        assert(input.length <= 0xffffffff);\n\n        // sets first four bytes in output as the input length\n        bytes memory inputLength = abi.encodePacked(input.length);\n        output[0] = inputLength[inputLength.length-4];\n        output[1] = inputLength[inputLength.length-3];\n        output[2] = inputLength[inputLength.length-2];\n        output[3] = inputLength[inputLength.length-1];\n\n        // subsequent bytes in output are the input bytes themselves\n        for (uint i = 0; i < input.length && i+4 < output.length; i++) {\n          output[i+4] = input[i];\n        }\n    }\n\n    function instantiate(address[] memory parties) public returns (uint256) {\n\n        // specifies two input drives containing the document and the signature\n        CartesiComputeInterface.Drive[] memory drives = new CartesiComputeInterface.Drive[](2);\n        drives[0] = CartesiComputeInterface.Drive(\n            0xa000000000000000,    // 3rd drive position: 1st is the root file-system (0x8000..), 2nd is the dapp-data file-system (0x9000..)\n            10,                    // driveLog2Size\n            documentData,          // directValue\n            \"\",                    // loggerIpfsPath\n            0x00,                  // loggerRootHash\n            parties[0],            // provider\n            false,                 // waitsProvider\n            false,                 // needsLogger\n            false                  // downloadAsCAR\n        );\n        drives[1] = CartesiComputeInterface.Drive(\n            0xb000000000000000,    // 4th drive position\n            10,                    // driveLog2Size\n            signatureData,         // directValue\n            \"\",                    // loggerIpfsPath\n            0x00,                  // loggerRootHash\n            parties[0],            // provider\n            false,                 // waitsProvider\n            false,                 // needsLogger\n            false                  // downloadAsCAR\n        );\n\n        // instantiates the computation\n        return cartesiCompute.instantiate(\n            finalTime,\n            templateHash,\n            outputPosition,\n            outputLog2Size,\n            roundDuration,\n            parties,\n            drives,\n            false\n        );\n    }\n\n    function getResult(uint256 index) public view returns (bool, bool, address, bytes memory) {\n        return cartesiCompute.getResult(index);\n    }\n}"
        }
    ]
}